# 程序的机器级表示

# 程序编码

两种抽象：

- 指令集体系结构：机器级程序的格式和行为
- 机器级程序使用的存储器地址是虚拟地址

---

一些在C语言中被隐藏的处理器状态：

- 程序计数器
- 整数寄存器
- 条件码寄存器
- 浮点寄存器
- 程序存储器
  
---

反汇编

根据目标代码生成一种类似于汇编代码的格式

- 设计指令格式的方式是，从某个给定位置开始，可以将字节唯一的解码成机器指令
- 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码

# 访问信息

操作数指示符

- 立即数（immediate）
  
  即常数值。其书写方式为 **'$'** 后面跟一个用标准C表示法的整数，如 $-577，$0x1F

- 寄存器（register）
  
  表示某个寄存器的内容

- 存储器（memory）引用
  
  根据计算出的地址（通常为有效地址）访问某个存储器位值

---

寻址模式

有效地址被计算为
$$Imm+R[E_b]+R[E_i]*s$$
其中$Imm$为立即数偏移；$E_b$为基址寄存器；$E_i$为变址寄存器；$s$为比例因子，且必须为1、2、4或8。

---

数据传输指令

- MOV类

---

算数和逻辑操作

- 加载有效地址
- 整数操作 P119 图3-7
- 一元操作和二元操作
- 移位操作
- 特殊的算术操作
  
---

## 控制

机器代码提供两种基本的低级机制来实现有条件的行为：

- 测试数据值，然后根据测试的结果来改变控制流或数据流
- 。。。

---

条件码

- CF：进位标志。最近的操作使最高位产生了进位。可以用来检查无符号操作数的溢出。
- ZF：零标志。最近的操作得出的结果为0.
- SF：符号标志。最近的操作得到的结果为负数。
- OF：溢出标志。最近的操作导致一个补码溢出——正溢出或负溢出。

---

访问条件码

- 可以根据条件码的某个组合，将一个字节设置为0或1。
  
  SET指令 P128 图3-11

- 可以条件跳转到程序的某个其他的部分
- 可以有条件的传送数据

---

jmp跳转指令及其编码

jmp指令是无条件跳转 P128 图3-12

- 直接跳转
  
  给出一个标号，直接跳转，如 jmp .L1

- 间接跳转

  '*'后面跟一个操作数指示符
  
  如，jmp *%eax，用寄存器%eax中的值作为跳转目标

  jmp *(%eax)，以%eax中的值作为读地址，从存储器中读出跳转目标

循环

do-while, while, for，利用条件测试和跳转组合来实现循环效果

其中对于while，GCC通常使用条件分支，在需要时省略循环体的第一次执行，从而将代码转换为do-while

for循环同while循环

---

条件传送指令

数据的替代转移，先计算一个条件操作的两种结果，然后再根据条件是否满足，从而选取一个。只有在一些受限制的条件下才可使用。

当分支预测错误的处罚时间主导函数性能时，基于条件数据传送的代码比基于条件控制转移的代码性能要好。

---

switch语句

- 使用跳转表来访问代码位置
- 使用跳转表是一种非常有效的实现多重分支的方法

# 过程

一个过程调用包括将数据（以过程参数和返回值的形式）和控制从代码的一部分传递到另一部分。还必须在进入时为过程的局部变量分配空间，并在退出时释放这些空间。

机器使用**栈**来传递过程参数、存储返回信息、保存寄存器用于以后恢复，以及本地存储。

- 为单个过程分配的那部分栈称为**栈帧**。
- 帧指针：寄存器%ebp，程序执行时不移动，因此大多信息的访问都是相对于帧指针。
- 栈指针：寄存器%esp，程序执行时可移动。
  
---

转移控制

- call指令：该指令的目标为被调用过程起始的指令地址。其效果为将返回地址入栈，并跳转到被调用过程的起始处。
- ret指令：从栈中弹出地址，并跳转到这个位值。
  
# 数组的分配和访问

C语言可以产生指向数组中元素的指针，并对这些指针进行计算。在机器代码中，这些指针会被翻译为**地址计算**。

嵌套的数组

  int A[5][3];
  等价于
  typedef int row3_t[3]
  row3_t A[5]

  数据类型row3_t被定义为一个含3个整数 的数组。数组A包含5个这样的元素。

---

# 异质的数据结构

- 结构：将多个对象集合到一个单位中
  
  结构的所有组成部分都存放在存储器中*一段连续的区域内*，而指向结构的指针就是结构第一个字节的地址。

  结构各个字段的选取完全是在编译时处理

- 联合：允许用几种不用的类型来引用一个对象
  
  一个联合的总大小等于他最大字段的大小

  通常引入一个枚举类型，定义这个联合中可能的不同选择

  ```
  typedef enum { N_LEAF, N_INTERNAL} nodetype_t;
  struct NODE_T {
    nodetype_t type;
    union{
      struct {
        struct NODE_T *left;
        struct NODE_T *right;
      } internal;
    } info;
  };
  ```

  使用联合可以节省空间

  联合还可以用来访问不同数据的位模式

---

# 综合：理解指针

指针以一种统一的方式，对不同数据结构中的元素产生引用。

- 每个指针都对应一个类型。
  
  这个类型表明指针指向哪一类对象。
  
  特殊的void*类型代表通用指针。

- 每个指针都有一个值。
  
  这个值是某个指定类型对象的地址。

  特殊的NULL(0)值表示该指针没有指向任何地方。

- 指针用&运算符创建

- 运算符*用于指针的间接引用

  间接引用是通过存储器引用实现的，要么是存储到一个指定的地址，要么是从指定的地址读取。

- 数组与指针紧密联系
  
- 将指针从一种类型强制转换为另一种类型，只改变它的类型，而不改变它的值

- 指针也可以指向函数
  
  函数指针的值是该函数机器代码表示中第一条指令的地址


# 存储器的越界引用和缓冲区溢出

对越界的数组元素的写操作会破坏存储在栈中的信息，几种错误有：

  1. 如果破坏了%ebx的值，则该存储器就不能正确地恢复，调用者就不能依靠这个存储器的正确性。
  2. 如果破坏了%ebp的值，则该寄存器就不能正确地恢复，调用者就不能正确地引用它的局部变量或者参数。
  3. 如果破坏了存储的返回地址，那么ret指令会使程序跳转到完全意想不到的地方。
