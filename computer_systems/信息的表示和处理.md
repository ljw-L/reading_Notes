# 信息的表示和处理

## 信息存储

- 小端法<br>
最低有效字节在最前面的方式
- 大端法<br>
最高有效字节在最前面的方式

---
从机器的角度看，程序仅仅只是字节序列。<br>

---

- 左移<br>
*x* 向左移动 *k* 位，丢掉最高的 *k* 位，并在右端补 *k* 个**0**
- 逻辑右移<br>
*x* 向右移动 *k* 位，丢掉最低的 *k* 位，并在左端补 *k* 个**0**
- 算术右移<br>
*x* 向右移动 *k* 位，丢掉最低的 *k* 位，并在左端补 *k* 个**最高有效位的值**<br>
|       操作       |       值1      |       值2      |
|:----------------:|:--------------:|:--------------:|
|       参数x      |   [01100011]   |   [10010101]   |
|      x << 4      | [0011**0000**] | [0101**0000**] |
| x >> 4(逻辑右移) | [**0000**0110] | [**0000**1001] |
| x >> 4(算数右移) | [**0000**0110] | [**1111**1001] |

---

- 右移的实际使用情况<br>
C语言标准没有明确定义使用哪种类型的右移<br>
对于无符号数据，右移必须是逻辑的<br>
对于有符号数据，算术或逻辑右移均可以，*导致潜在的可移植性问题*，一般而言编译器/机器对有符号数据采用算术右移<br>

---

## 整数表示

表示**有限范围**的整数

- 无符号数<br>
对于无符号数的二进制表示，每个介于$(0, 2^w-1)$之间的数都有唯一一个 *w* 位的值编码<br>
- 补码编码<br>
最高有效位被解释为**负权**，故$x_{w-1}$也称为*符号位*，其权重为$-2^{w-1}$。<br>
例如: <br>
[1111] → -8 + 4 + 2 + 1 = -1 <br>
[0101] → -0 + 4 + 0 + 1 = 5 <br>

---

- 补码的范围是不对称的
- 为保证程序的可移植性，除了在p42所示的图2-13数值范围内，不应该假设任何其他的可表示的数值范围
- 也不能假设**有符号数**会使用何种特殊的表示方式
- C库文件中的<limits.h>定义了一组常量，用以限定编译器运行的这台机器上的不同整数类型的取值范围

---
有符号数和无符号数之间的转换<br>

- 强制类型转换的结果保持**位值**不变，只是*改变了解释这些位的方式*<br>
- 对于C语言，处理相同字长的有符号数和无符号数之间相互转换的一般为则为：<br>
数值可能会改变，但是位模式不变<br>
- 通常，大多数数字都默认为有符号，用补码形式表达；若要创建一个无符号常量，必须加上后缀U或者u，如**123U**或者**0x1A2Bu**<br>

---
有符号数和无符号数之间的运算<br>

- 当执行一个运算时，如果他的一个运算数是有符号的，而另一个是无符号的，那么C语言就会隐式地将**有符号参数**转换**为无符号参数**，并假设这两个数都是**非负**的<br>
- 当有符号数和无符号数进行关系运算时，可能会出现非直观的结果，如  -1<0U 的运算结果为 0 ；而-1 < 0 的运算结果为 1 。<br>

---
拓展数字的位表示<br>

- 零拓展<br>
将一个无符号数转换为一个更大的数据类型，只需要在表示的开头添加0<br>
- 符号拓展<br>
将一个补码数字转换为一个更大的数据类型，在表示中**添加最高有效位的值的副本**。设原始值的位表示为$[x_{w-1}, x_{w-2}, ..., x_{0}]$，则拓展后的表示为$[x_{w-1}, ..., x_{w-1}, x_{w-1}, x_{w-2}, ..., x_{0}]$<br>

---

数字截断

- 当$[x_{w-1}, x_{w-2}, ..., x_{0}]$截断为一个*k*位的数字时，会丢弃高*w-k*位，得到$[x_{k-1}, x_{k-2}, ..., x_{0}]$
- 截断一个数字可能会改变它的值——溢出的一种形式
- 对于无符号数字，截断它的*k*位就相当于计算$x$ mod $2^k$

---
特别注意点

- 有符号数到无符号数的隐式强制转换会导致某些非直观的行为，从而导致程序出现错误
- 基于有符号数和无符号数的运算规则，由于某些函数的返回值由 **unsigned** 修饰，故其返回值为无符号数，在后续使用该无符号数值时需额外注意。
- 此外有些返回值为**size_t**等没有显示出现**unsigned**，但实际被定义为无符号数，也需要额外注意
- 总之，使用函数时，一定要搞清楚他的返回值是什么类型，会对后续参与的运算造成影响
- 避免这种困境的一种方法为，不使用无符号数

## 整数运算

无符号运算可以被视为一种模运算形式
- 溢出<br>
  算数溢出指完整的整数结果不能放到数据类型的字长限制中去。<br>
  当$s=^.x +_w^u y$时，若$s<x(s<y>)$时，发生了溢出

---

- 无符号加法<br>
即为计算和模上$2^w$<br>
对于$0 \leq x,y <2^w$，
$$
x+y=\left\{
\begin{aligned}
 x+_w^uy,        &   &   x+y<2^w \\
 x+_w^uy-2^w,    &   &   2^w\leq x+y<2^{w+1}
\end{aligned}
\right.
$$

---

- 补码加法<br>
对于$-2^{w-1} \leq x,y \leq 2^{w-1}-1$之间的数进行$+^t_w$时，<br>
$$
x +^t_w y=
\left\{
    \begin{aligned}
    x+y-2^w,&    &2^{w-1} \leq x+y,&                &正溢出\\
    x+y,    &    &-2^{w-1} \leq x+y \leq 2^{w-1},&  &正常\\
    x+y+2^w,&    &x+y<-2^{w-1},&                    &负溢出
    \end{aligned}
\right.
$$

---

补码的非<br>
$$
-^t_wx=
\left\{
    \begin{aligned}
    -2^{w-1},&  &x=-2^{w-1}\\
    -x,      &  &x>-2^{w-1}
    \end{aligned}
\right.
$$

---

- 位级补码非<br>
  计算一个数 $x$ 的位级补码非，对每一位求补，再对结果+1。<br>

---

无符号乘法

- C语言中无符号乘法被定义为产生 $w$ 位的值，即 $2w$ 位整数乘积的低 $w$ 位表示的值，等价于计算结果模 $2^w$.<br>
$x*^u_wy=(x\bullet y)$ mod $2^w$

有符号乘法<br>

- 对于无符号和补码乘法来说，乘法运算的位级表示是一样的<br>
- *w*位的补码乘法运算$*^t_w$的结果为:<br>
$x *^t_w y = U2T_w ((x\bullet y)$ mod $2^w$)

- 乘以常数<br>
用移位和加法(减法)的组合来代替乘以常数因子的乘法 <br>
形式A：$(x<<n)+(x<<n-1)+...+(x<<m)$
形式B：$(x<<n+1)-(x<<m)$

## 浮点数
有点复杂，后续再看

